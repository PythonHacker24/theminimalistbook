<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" href="/favicon.ico">

  <title>
    Tree Traversal - Depth First Search - In Order Search - The Minimalist&#39;s Book
  </title>

  <meta name="description" content="In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree." /><meta name="generator" content="Hugo 0.126.1">

  <link rel="stylesheet" href="https://minimalistbook.com/css/main.css" />

  
  

  <meta property="og:url" content="https://minimalistbook.com/algorithms/tree_traversal_depth_first_search_in_order_search/">
  <meta property="og:site_name" content="The Minimalist&#39;s Book">
  <meta property="og:title" content="Tree Traversal - Depth First Search - In Order Search">
  <meta property="og:description" content="In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="algorithms">
    <meta property="og:image" content="https://minimalistbook.com/digital-garden-logo.png">


  
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://minimalistbook.com/digital-garden-logo.png">
  <meta name="twitter:title" content="Tree Traversal - Depth First Search - In Order Search">
  <meta name="twitter:description" content="In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.">


  
  <meta itemprop="name" content="Tree Traversal - Depth First Search - In Order Search">
  <meta itemprop="description" content="In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.">
  <meta itemprop="wordCount" content="264">
  <meta itemprop="image" content="https://minimalistbook.com/digital-garden-logo.png">

  
  <meta itemprop="name" content="Tree Traversal - Depth First Search - In Order Search">
  <meta itemprop="description" content="In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.">
  <meta itemprop="wordCount" content="264">
  <meta itemprop="image" content="https://minimalistbook.com/digital-garden-logo.png">
</head><body class="flex relative h-full min-h-screen"><aside
  class="will-change-transform transform transition-transform -translate-x-full absolute top-0 left-0 md:relative md:translate-x-0 w-3/4 md:basis-60 h-full min-h-screen p-3 bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col gap-2.5 z-20 sidebar flex-shrink-0">
  <p class="font-bold mb-5 flex items-center gap-2">
    <button aria-label="Close sidebar"
      class="md:hidden menu-trigger-close p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-6 w-6" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <line x1="18" y1="6" x2="6" y2="18" />
  <line x1="6" y1="6" x2="18" y2="18" />
</svg></button>
    <a href="https://minimalistbook.com/" class="px-2">
      <span>The Minimalist&#39;s Book</span>
    </a>
    <button aria-label="Toggle dark mode"
      class="dark-mode-toggle p-2 rounded border dark:border-slate-700 hover:bg-slate-200 dark:hover:bg-slate-700"><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <circle cx="12" cy="12" r="4" />
  <path d="M3 12h1M12 3v1M20 12h1M12 20v1M5.6 5.6l.7 .7M18.4 5.6l-.7 .7M17.7 17.7l.7 .7M6.3 17.7l-.7 .7" />
</svg></button>
  </p>

  
  <ul class="list-none flex flex-col gap-1">
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/" >
        <span>Home</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  text-slate-400 font-semibold pb-0 pl-1 border-b cursor-default pointer-events-none "
        href="#" >
        <span>Explore</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/technical" >
        <span>Technical Writings</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/thinkings" >
        <span>Thinkings</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/projects" >
        <span>Projects</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/backpack" >
        <span>Backpack</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  text-slate-400 font-semibold pb-0 pl-1 border-b cursor-default pointer-events-none "
        href="#" >
        <span>DSA for Devs</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/data_structures" >
        <span>Data Structures in C&#43;&#43;</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms" >
        <span>Algorithms in C&#43;&#43;</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  text-slate-400 font-semibold pb-0 pl-1 border-b cursor-default pointer-events-none "
        href="#" >
        <span>Links</span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm flex items-center justify-between  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="https://medium.com/@adityapatil24680"  target="_blank"
        rel="noopener" >
        <span>Medium</span>
        
        <span><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <path d="M11 7h-5a2 2 0 0 0 -2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2 -2v-5" />
  <line x1="10" y1="14" x2="20" y2="4" />
  <polyline points="15 4 20 4 20 9" />
</svg></span>
        
      </a>
    </li>
    
  </ul>

  <div class="flex-1"></div>

  <div class="newsletter-widget">
  <div class="text-bold text-sm">The Minimalist Newsletter</div>
  
  <p class="text-xs my-1 text-slate-500">A minimal newsletter with summaries of my latest writings and updates to your mailbox</p>
  

  
  
  
  

  

  <form action="https://minimalist-newsletter.beehiiv.com/subscribe" method="post" id="newsletter_form" name="revue-form" target="_blank">
    <div class="mt-2">
      
      
      <button onclick="window.open('https://minimalist-newsletter.beehiiv.com/subscribe', '_blank')" class="mt-2 w-full text-center text-sm bg-slate-800 text-white dark:bg-slate-50 dark:text-slate-800 py-1 rounded cursor-pointer">Subscribe</button>
    </div>
  </form>

  
</div>


  
  <a href="https://www.producthunt.com/posts/the-minimalist-book?embed=true&utm_source=badge-featured&utm_medium=badge&utm_souce=badge-the&#0045;minimalist&#0045;book" target="_blank"><img src="https://api.producthunt.com/widgets/embed-image/v1/featured.svg?post_id=461338&theme=light" alt="The&#0032;Minimalist&#0032;Book - A&#0032;Minimalist&#0032;Platform&#0032;for&#0032;Minimalist&#0032;Engineers | Product Hunt" style="width: 250px; height: 54px;" width="250" height="54" /></a>

  <ul class="list-none flex flex-wrap justify-center gap-1 pt-2 border-t border-slate-200 dark:border-slate-600">
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="https://github.com/PythonHacker24" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">GitHub</span>
        
        <span><svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
  stroke-linecap="round" stroke-linejoin="round">
  <path
    d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" />
</svg></span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="https://www.linkedin.com/in/aditya-patil-260a631b2/" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">LinkedIn</span>
        
        <span><svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
  stroke-linecap="round" stroke-linejoin="round">
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z" />
  <rect x="2" y="9" width="4" height="12" />
  <circle cx="4" cy="4" r="2" />
</svg></span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="adityapatil24680@gmail.com" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">Email</span>
        
        <span><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <rect x="3" y="5" width="18" height="14" rx="2" />
  <polyline points="3 7 12 13 21 7" />
</svg></span>
        
      </a>
    </li>
    
    <li>
      <a class="px-2 py-1.5 rounded-md text-sm block text-slate-800 dark:text-slate-50  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/index.xml" target="_blank" rel="noopener noreferrer">
        <span class="sr-only">RSS</span>
        
        <span><svg class="h-4 w-4" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <circle cx="5" cy="19" r="1" />
  <path d="M4 4a16 16 0 0 1 16 16" />
  <path d="M4 11a9 9 0 0 1 9 9" />
</svg></span>
        
      </a>
    </li>
    
  </ul>
</aside>

<div
  class="fixed bg-slate-700 bg-opacity-5 transition duration-200 ease-in-out inset-0 z-10 pointer-events-auto md:hidden left-0 top-0 w-full h-full hidden menu-overlay">
</div>

<button aria-label="Toggle Sidebar"
  class="md:hidden absolute top-3 left-3 z-10 menu-trigger p-1 rounded text-slate-800 dark:text-slate-50 hover:bg-slate-100"><svg class="h-6 w-6" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"
  fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" />
  <line x1="4" y1="6" x2="20" y2="6" />
  <line x1="4" y1="12" x2="20" y2="12" />
  <line x1="4" y1="18" x2="16" y2="18" />
</svg></button>






<div class="flex flex-1 h-screen relative w-full min-w-0">

  <section
    class="will-change-transform transform transition-transform -translate-x-[200%] absolute top-0 left-0 lg:relative
  lg:translate-x-0 lg:basis-[400px] h-full bg-slate-50 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 lg:flex flex-col py-3 overflow-y-auto scroll-area flex-shrink-0">
    
    
    <a href="https://minimalistbook.com/algorithms/">
      <h2 class="font-bold mb-5 py-1 pl-12 pr-3 md:px-3">Algorithms in C&#43;&#43;</h2>
    </a>
<label class="mb-2 block px-2">
  <span></span>
  <input type="text" placeholder="Search articles" class="searchInput bg-white rounded px-2 py-1 w-full border" />
</label>
<script>
  const searchElt = document.querySelector('.searchInput')
  if (searchElt) {
    searchElt.addEventListener('input', evt => {
      const value = evt.target.value || '';

      const articles = document.querySelectorAll('.article')
      if (!value) {
        articles.forEach(article => article.classList.remove('hidden'))
      } else {
        articles.forEach(article => article.classList.add('hidden'))
        Array.from(articles).filter(article => {
          const title = article.querySelector('h3')
          if (!title) return false;

          return title.textContent.toLowerCase().includes(value.toLowerCase())
        }).forEach(article => article.classList.remove('hidden'))
      }
    })
  }
</script>
<div class="space-y-2.5">
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/bubble_sort/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Bubble Sort</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Bubble Sort is a simple, comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted. While easy to understand and implement, Bubble Sort is inefficient for large lists, with a worst-case and average-case time complexity of O(n^2).
#include &lt;iostream&gt; #include &lt;array&gt; using namespace std; // This function will carry out the operations in the algorithm of Bubble Sort Method int bubbleSort(int array[], int size){ for (int i = size - 1; i &gt; 0; i--){ for (int j = 0; j &lt; i; j++){ if (array[j] &gt; array[j+1]){ int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; } } } } int main(){ int myArray[] = {6, 4, 3, 6, 7, 8, 1, 4, 5, 3}; int size = sizeof(myArray) / sizeof(myArray[0]); // This is the method for calculating the length of an array bubbleSort(myArray, size); for (auto value: myArray){ cout &lt;&lt; value &lt;&lt; endl; } } // Operational Complexity for Bubble Sort is O(n^2) 
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/insertion_sort/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Insertion Sort</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Insertion Sort is a simple, comparison-based sorting algorithm that builds the final sorted array one element at a time. It works by repeatedly picking the next element from the unsorted portion and inserting it into the correct position within the sorted portion, effectively shifting elements as necessary to make space. This algorithm is efficient for small data sets or nearly sorted arrays but has a quadratic time complexity of O(n^2) for larger, unordered lists.
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/merge_sort/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Merge Sort</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Merge Sort is a stable, comparison-based sorting algorithm that uses the divide-and-conquer strategy. It works by recursively dividing the array into halves until each sub-array contains a single element, then merges the sub-arrays back together in sorted order. This algorithm is efficient with a consistent time complexity of O(nlogn) and is particularly useful for sorting linked lists and large datasets.
# include &lt;iostream&gt; using namespace std; void merge(int array[], int leftIndex, int midIndex, int rightIndex){ // Calculating size of the two arrays that are derived from splitting the array int leftArraySize = midIndex - leftIndex + 1; int rightArraySize = rightIndex - midIndex; // Declaring new arrays where these splitted arrays are going to be defined int leftArray[leftArraySize]; int rightArray[rightArraySize]; // Loading new arrays with right and left elements of the array for (int i = 0; i &lt; leftArraySize; i++){ leftArray[i] = array[leftIndex + i]; } for (int j = 0; j &lt; rightArraySize; j++){ rightArray[j] = array[midIndex + 1 + j]; } // initializing variables int index = leftIndex; int i = 0; int j = 0; // Arranging the main array with elements in order of small to large size from the leftArray and rightArray while (i &lt; leftArraySize &amp;&amp; j &lt; rightArraySize){ if (leftArray[i] &lt;= rightArray[j]){ array[index] = leftArray[i]; index++; i++; } else{ array[index] = rightArray[j]; index++; j++; } } // If leftArray elements are left over, add them at the end of the main array while (i &lt; leftArraySize){ array[index] = leftArray[i]; index++; i++; } // If rightArray elements are left over, add them at the end of the main array while (j &lt; rightArraySize){ array[index] = rightArray[j]; index++; j++; } } void mergeSort(int array[], int leftIndex, int rightIndex){ if (leftIndex &gt;= rightIndex) return; int midIndex = leftIndex + (rightIndex - leftIndex) / 2; mergeSort(array, leftIndex, midIndex); mergeSort(array, midIndex + 1, rightIndex); merge(array, leftIndex, midIndex, rightIndex); } int main(){ int myArray[] = {3, 1, 4, 2}; int size = sizeof(myArray) / sizeof(myArray[0]); int leftIndex = 0; int rightIndex = size - 1; mergeSort(myArray, leftIndex, rightIndex); for(auto value : myArray){ cout &lt;&lt; value &lt;&lt; &#34; &#34;; } } 
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/quick_sort/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Quick Sort</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Quick Sort is a highly efficient, comparison-based sorting algorithm that uses the divide-and-conquer strategy to sort elements. It works by selecting a &lsquo;pivot&rsquo; element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted. Quick Sort has an average-case time complexity of O(nlogn) and is generally faster in practice compared to other O(nlogn) algorithms like Merge Sort, though its worst-case complexity is O(n^2).
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/selection_sort/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Selection Sort</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Selection Sort is a simple, comparison-based sorting algorithm that sorts an array by repeatedly finding the minimum element from the unsorted portion and swapping it with the first unsorted element. This process continues moving the boundary of the sorted and unsorted subarrays. While easy to understand and implement, Selection Sort is inefficient for large datasets, with a time complexity of O(n^2).
# include &lt;iostream&gt; # include &lt;array&gt; using namespace std; // This function will carry out the operations in the algorithm of Selection Sort Method int selectionSort(int array[], int size){ for (int i = 0; i &lt; size; i++){ int minIndex = i; for (int j = i + 1; j &lt; size; j++){ if (array[j] &lt; array[minIndex]){ minIndex = j; } } if (i !
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/tree_traversal_breath_first_search/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Tree Traversal - Breath First Search</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Breadth-First Search is a tree traversal algorithm that explores nodes level by level. Starting from the root, it visits all nodes at the current level before moving on to the nodes at the next level. BFS uses a queue to keep track of the nodes to be explored, ensuring that nodes are processed in the order they are discovered. This method is effective for finding the shortest path in unweighted graphs and has a time complexity of O(V+E), where V is the number of vertices and E is the number of edges.
        </div>
      </a>
      
      <a class="article block px-3 py-4  bg-slate-900 dark:bg-slate-700 text-slate-50 "
        href="/algorithms/tree_traversal_depth_first_search_in_order_search/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Tree Traversal - Depth First Search - In Order Search</h3>
        <div
          class="text-sm  text-slate-400  line-clamp-2">
          In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/tree_traversal_depth_first_search_post_order/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Tree Traversal - Depth First Search - Post Order</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Post-Order Traversal is a type of depth-first search that visits nodes in a left-right-root sequence: it first recursively visits the left subtree, then the right subtree, and finally processes the current node. This traversal is useful for operations where a node must be processed only after all its children have been processed, such as deleting nodes in a tree or evaluating expressions in a syntax tree. The time complexity is O(n), where n is the number of nodes in the tree.
        </div>
      </a>
      
      <a class="article block px-3 py-4  hover:bg-slate-200 dark:hover:bg-slate-700 "
        href="/algorithms/tree_traversal_depth_first_search_pre_order/">
        
        
        <h3 class="text-lg font-semibold mb-0.5">Tree Traversal - Depth First Search - Pre Order</h3>
        <div
          class="text-sm  text-slate-500 dark:text-slate-400  line-clamp-2">
          Pre-Order Traversal is a type of depth-first search that visits nodes in a root-left-right sequence: it processes the current node first, then recursively visits the left subtree, followed by the right subtree. This traversal is useful for creating a copy of the tree, prefix expression evaluations, and hierarchical structures where the root node is processed before its subtrees. The time complexity is O(n), where n is the number of nodes in the tree.
        </div>
      </a>
      </div>
    </section>

  <div class="overflow-y-auto h-screen w-full">
    <article class="px-6 py-20 w-full mx-auto prose lg:prose-lg h-fit dark:prose-invert prose-img:mx-auto">

      
      <h1 class="!mb-2">Tree Traversal - Depth First Search - In Order Search</h1>

	  

      

      <p>In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;iostream&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6">#include</span> <span style="color:#ff79c6">&lt;queue&gt;</span><span style="color:#ff79c6">
</span></span></span><span style="display:flex;"><span><span style="color:#ff79c6"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">using</span> <span style="color:#ff79c6">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">Node</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd">int</span> value;
</span></span><span style="display:flex;"><span>		Node<span style="color:#ff79c6">*</span> right;
</span></span><span style="display:flex;"><span>		Node<span style="color:#ff79c6">*</span> left;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		Node(<span style="color:#8be9fd">int</span> value){
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">this</span><span style="color:#ff79c6">-&gt;</span>value <span style="color:#ff79c6">=</span> value;
</span></span><span style="display:flex;"><span>			right <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
</span></span><span style="display:flex;"><span>			left <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">BinarySearchTree</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>		Node<span style="color:#ff79c6">*</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">public</span><span style="color:#ff79c6">:</span>
</span></span><span style="display:flex;"><span>		BinarySearchTree(){
</span></span><span style="display:flex;"><span>			root <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">nullptr</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd">bool</span> <span style="color:#50fa7b">insert</span>(<span style="color:#8be9fd">int</span> value){
</span></span><span style="display:flex;"><span>			Node<span style="color:#ff79c6">*</span> newNode <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Node(value);
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> (root <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nullptr</span>){
</span></span><span style="display:flex;"><span>				root <span style="color:#ff79c6">=</span> newNode;
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			Node<span style="color:#ff79c6">*</span> temp <span style="color:#ff79c6">=</span> root;
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">while</span> (<span style="color:#8be9fd;font-style:italic">true</span>){
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> (newNode<span style="color:#ff79c6">-&gt;</span>value <span style="color:#ff79c6">==</span> temp<span style="color:#ff79c6">-&gt;</span>value) <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> (newNode<span style="color:#ff79c6">-&gt;</span>value <span style="color:#ff79c6">&lt;</span> temp<span style="color:#ff79c6">-&gt;</span>value){
</span></span><span style="display:flex;"><span>					<span style="color:#ff79c6">if</span> (temp<span style="color:#ff79c6">-&gt;</span>left <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nullptr</span>){
</span></span><span style="display:flex;"><span>						temp<span style="color:#ff79c6">-&gt;</span>left <span style="color:#ff79c6">=</span> newNode;
</span></span><span style="display:flex;"><span>						<span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>					temp <span style="color:#ff79c6">=</span> temp<span style="color:#ff79c6">-&gt;</span>left;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">else</span>{
</span></span><span style="display:flex;"><span>					<span style="color:#ff79c6">if</span> (temp<span style="color:#ff79c6">-&gt;</span>right <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nullptr</span>){
</span></span><span style="display:flex;"><span>						temp<span style="color:#ff79c6">-&gt;</span>right <span style="color:#ff79c6">=</span> newNode;
</span></span><span style="display:flex;"><span>						<span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>					temp <span style="color:#ff79c6">=</span> temp<span style="color:#ff79c6">-&gt;</span>right;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd">bool</span> <span style="color:#50fa7b">contains</span>(<span style="color:#8be9fd">int</span> value){
</span></span><span style="display:flex;"><span>			Node<span style="color:#ff79c6">*</span> temp <span style="color:#ff79c6">=</span> root;
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">while</span> (temp){
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">if</span> (value <span style="color:#ff79c6">&lt;</span> temp<span style="color:#ff79c6">-&gt;</span>value){
</span></span><span style="display:flex;"><span>					temp <span style="color:#ff79c6">=</span> temp<span style="color:#ff79c6">-&gt;</span>left;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (value <span style="color:#ff79c6">&gt;</span> temp<span style="color:#ff79c6">-&gt;</span>value){
</span></span><span style="display:flex;"><span>					temp <span style="color:#ff79c6">=</span> temp<span style="color:#ff79c6">-&gt;</span>right;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#ff79c6">else</span>{
</span></span><span style="display:flex;"><span>					<span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">DFSInOrder</span>(Node<span style="color:#ff79c6">*</span> currentNode){
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> (currentNode<span style="color:#ff79c6">-&gt;</span>left){
</span></span><span style="display:flex;"><span>				DFSInOrder(currentNode<span style="color:#ff79c6">-&gt;</span>left);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			cout <span style="color:#ff79c6">&lt;&lt;</span> currentNode<span style="color:#ff79c6">-&gt;</span>value <span style="color:#ff79c6">&lt;&lt;</span> <span style="color:#f1fa8c">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>			<span style="color:#ff79c6">if</span> (currentNode<span style="color:#ff79c6">-&gt;</span>right){
</span></span><span style="display:flex;"><span>				DFSInOrder(currentNode<span style="color:#ff79c6">-&gt;</span>right);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// Function overloading 
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#8be9fd">void</span> <span style="color:#50fa7b">DFSInOrder</span>() {
</span></span><span style="display:flex;"><span>			DFSInOrder(root);
</span></span><span style="display:flex;"><span>		}	
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd">int</span> <span style="color:#50fa7b">main</span>(){
</span></span><span style="display:flex;"><span>    BinarySearchTree<span style="color:#ff79c6">*</span> myBST <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BinarySearchTree;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">12</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">4</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">23</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">45</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">21</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">76</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">44</span>);
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>insert(<span style="color:#bd93f9">54</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    myBST<span style="color:#ff79c6">-&gt;</span>DFSInOrder();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </article>
  </div>

</div>


  
<script type="text/javascript" src="/main.js" defer></script>


  


</body>

</html>