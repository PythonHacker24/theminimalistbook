<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Homepage on The Minimalist&#39;s Book</title>
    <link>/</link>
    <description>Recent content in Homepage on The Minimalist&#39;s Book</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tmux is the Ultimate Choice for Power Users - An Awesome Terminal Multiplexer for Managing Persistent Sessions</title>
      <link>/technical/tmux_is_the_ultimate_choice_for_power_users/</link>
      <pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate>
      <guid>/technical/tmux_is_the_ultimate_choice_for_power_users/</guid>
      <description>What is Tmux? Tmux is a Terminal Multiplexer Application for Linux and MacOS for managing terminal sessions and Windows. It is to be mentioned that Tmux is not a terminal emulator, instead, it’s a terminal application, a binary that allows you to stay productive over your terminal. It doesn’t matter which terminal emulator you are using (although I recommend the Suckless Terminal). The functionality of managing Windows and the session doesn’t happen on the desktop GUI side but on the terminal session, you are working with.</description>
    </item>
    <item>
      <title>The Future of Work and Lifestyle - The Inevitable Change in Thinking and Growth</title>
      <link>/thinkings/the_future_of_work_and_lifestyle/</link>
      <pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate>
      <guid>/thinkings/the_future_of_work_and_lifestyle/</guid>
      <description>The Current System of Workspace Working for a company or an organisation to become financially stable surely makes you and your family proud, and certainly, when you were in the 90s, that’s what most people termed as widely successful. It’s absolutely important to make money to have a nice home and send your kids to a good school. And most of the time that works and maybe certainly enough. This method of surviving has dominated for a while now and has shaped the current workspace.</description>
    </item>
    <item>
      <title>The Concept of RSS Feed - A Reliable Way for Publishers and Subscribers Model</title>
      <link>/technical/concept_of_rss_feed/</link>
      <pubDate>Tue, 21 May 2024 00:00:00 +0000</pubDate>
      <guid>/technical/concept_of_rss_feed/</guid>
      <description>Preface: I have been looking for simple solutions in nearly everything related to computing. A lot of software designed these days is not designed per your requirements but as per companies&amp;rsquo; profit. Hence, most of these solutions end up sucking your time and energy and need to be replaced by more optimised solutions that would boost your productivity in the right way. RSS Feed is something that I found after searching for solutions related to subscribing to websites or creators without sucking much resources and design that is reliable to the user itself.</description>
    </item>
    <item>
      <title>Breaking RSA Encryption on Hardware Devices with Side Channel Power Analysis — Leaking the Private Key by Exploiting Square-Multiply Algorithm</title>
      <link>/technical/breaking_rsa_encryption_on_hardware_devices_with_side_channel_power_analysis/</link>
      <pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate>
      <guid>/technical/breaking_rsa_encryption_on_hardware_devices_with_side_channel_power_analysis/</guid>
      <description>Preface: This article is about leaking the private key from hardware devices that implement RSA encryption which is part of hardware hacking. The author is not responsible for any damage caused by the given information. It is recommended to be careful while performing these attacks as they can damage the hardware or even destroy it. All the information provided here is for educational purposes. There are no such prerequisites for understanding the theory, although knowledge about modular arithmetic, basics of encryption mathematics, basic electronics, etc.</description>
    </item>
    <item>
      <title>Serious Reconnaissance with Unmanned Aerial Vehicles — Mapping Out Devices in an Area with Drones</title>
      <link>/technical/serious_reconnaissance_with_unmaned_aerial_vechiles/</link>
      <pubDate>Tue, 02 Apr 2024 00:00:00 +0000</pubDate>
      <guid>/technical/serious_reconnaissance_with_unmaned_aerial_vechiles/</guid>
      <description>Introduction: The following content is for educational purposes and for hackers living in basements knowing enough ethics. The author is not responsible for any damage caused by the knowledge provided here and does not support anything like that. It’s essential to check out the rules in the area of reconnaissance about the tactics provided here and the use of materials (unless and until there is any apocalypse and a solid recon is required).</description>
    </item>
    <item>
      <title>The Fundamentals of Hardware Hacking — Breaking and Reverse Engineering Smart IoT Devices</title>
      <link>/technical/fundamentals_of_hardware_hacking/</link>
      <pubDate>Fri, 15 Mar 2024 00:00:00 +0000</pubDate>
      <guid>/technical/fundamentals_of_hardware_hacking/</guid>
      <description>Disclaimer — This is an introductory article about Hardware Hacking and Security of IoT Devices. None of the mentioned information or techniques are intended for any illegal purposes and the author is not responsible for any damage. It’s advisable to experiment on devices that you own or have explicit permission to do so. Rest of all, hardware hacking is fun!&#xA;The Beauty of Electronic Devices In the ever-growing world of smart devices and the connectivity of things to the internet, life has become more convenient than ever.</description>
    </item>
    <item>
      <title>Setting Up a Remote Git Server — A Simple and Concise Step-by-Step Guide to Host a Private Git Server</title>
      <link>/technical/setting_up_remote_git_server/</link>
      <pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/technical/setting_up_remote_git_server/</guid>
      <description>Preface: This is a concise and simple guide to hosting a remote git server. I have been researching this topic for a while and came up with the idea of writing an article with a step-by-step guide for hosting a private git server. Covering all the aspects of git is not possible in a single article, so it’s assumed that the reader has prior knowledge of git and version control.</description>
    </item>
    <item>
      <title>The Nature of Linux Kernel Development — Difference Between Rules of Kernel Level and User-Space Application Level</title>
      <link>/technical/nature_of_linux_kernel_development/</link>
      <pubDate>Sun, 04 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/technical/nature_of_linux_kernel_development/</guid>
      <description>Preface: This article is intended to explain a clear distinction between the core principles of Linux Kernel Development and User-Application Level Development. The provided information is based on my research on Kernel Development through various sources and I have tried to make it as accurate as possible. Efforts have been made to explain it as simply and concisely as possible.&#xA;Introduction to the Nature of Linux Kernel Linux Kernel is the abstraction layer between the Operating System and the Hardware in the system.</description>
    </item>
    <item>
      <title>Linux Process Scheduling — The Reason your Linux System Processes so Efficiently (Kernel Perspective)</title>
      <link>/technical/linux_process_scheduling/</link>
      <pubDate>Fri, 02 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/technical/linux_process_scheduling/</guid>
      <description>Preface: I was going through the book “Linux Kernel Development” by Robert Love, one of the best books I have referred to for low-level stuff and understanding the workings of Linux. I study this book with intensity, simplify the concepts and write it down here so that the readers can get a straightforward description and all they need to know about the topic. Covering the whole Linux Process Scheduling is not possible and is not the goal of this article.</description>
    </item>
    <item>
      <title>Linux Processes — A Kernel’s Perspective Explained with Clarity and Simplicity</title>
      <link>/technical/linux_processes/</link>
      <pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/linux_processes/</guid>
      <description>Preface: I have been going through the book “Linux Kernel Development” by Robert Love which I highly recommend for understanding the Linux Kernel in depth. I decided to write this article to explain “Linux Processes” simply and concisely. The topic itself is broad and is not explained into the deepest of it, but essential for Linux Administrators, Developers and even Linux users to appreciate the beauty of the Kernel they make use of every day.</description>
    </item>
    <item>
      <title>NGINX for Deploying Next.js Application on AWS EC2 with AWS ELB — Control and Stability of Deployments</title>
      <link>/technical/nginx_for_deploying_nextjs_application_on_aws/</link>
      <pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/nginx_for_deploying_nextjs_application_on_aws/</guid>
      <description>I was looking for an article like this a few days ago, which I didn’t find at that time, so I did the deployment on my own and came up with this article to prevent other developers from saving those efforts and focusing on development. I am not explaining every single step and have provided links for references.&#xA;I prefer manual deployment of applications over automated (and even serverless) methods. Although they are convenient and require less effort by the developers, they are bound to the providers and offer less control over the underlying system.</description>
    </item>
    <item>
      <title>Configuring and Building the Linux Kernel — Absolute Guide to Compiling Your Kernel</title>
      <link>/technical/configuring_and_building_the_linux_kernel/</link>
      <pubDate>Thu, 25 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/configuring_and_building_the_linux_kernel/</guid>
      <description>Linux Kernel is an Open-Source Software and the user is free to modify and customise it as per the requirements. The modification of the Kernel requires a deep understanding of the working of the Kernel, although patches are available to make the Kernel optimised for specific hardware. Linux Kernel Source Code has various options to configure the drivers, modules, preferences on hardware options, etc. This part can be studied by the user and is pretty much easy to work with.</description>
    </item>
    <item>
      <title>The Elegance of the Linux Kernel — A Concise History of Unix and the Creation of the Linux Kernel</title>
      <link>/technical/elegance_of_the_linux_kernel/</link>
      <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/elegance_of_the_linux_kernel/</guid>
      <description>Introduction and Context I was going through the book “Linux Kernel Development” by Robert Love, an absolute guide to getting started with Linux Kernel Development and a highly recommended book for understanding the core of the Linux Kernel. Linux Kernel has been one of the most important software ever written and is even considered one of the biggest projects ever undertaken by a single person. The idea of the Linux Kernel was initiated by Linus Torvalds, a student from the University of Helsinki and is maintained by him to date (while writing this article).</description>
    </item>
    <item>
      <title>There are always Flaws — Malware Development and Exploitation of Control Flow</title>
      <link>/thinkings/there_are_always_flaws/</link>
      <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/thinkings/there_are_always_flaws/</guid>
      <description>Disclaimer: The Author of the article does not hold any opinions of facts other than computer technology. Everything here is as per my research and may not be fully accurate (although I tried my best). He is a very simple person and a computer nerd so information in this blog must be taken with a pinch of salt.&#xA;I have been studying Cyber Security since an early age and know a few things about it till now.</description>
    </item>
    <item>
      <title>Linux Shell Scripting — A Suckless and Concise Guide to the Command-line of Linux</title>
      <link>/technical/linux_shell_scripting/</link>
      <pubDate>Fri, 19 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/linux_shell_scripting/</guid>
      <description>Prior Statements: This is a concise guide on the Linux Shell Scripting while consolidating all the facts about the Linux Shell for quick developer’s reference while using Linux. I am referencing the Bash (Bourne-Again Shell) which is the default shell for Linux-based systems. I will also be providing references and external links to dive into depth and not fill the article with too much explanation about a single topic which is not universally required by all the readers.</description>
    </item>
    <item>
      <title>Suckless Utilities for Arch Linux — The Most Minimal Way Run a Computer</title>
      <link>/technical/suckless_utilities_for_arch_linux/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/suckless_utilities_for_arch_linux/</guid>
      <description>Suckless utilities have been my favourite at this time and kind of essentials for my use of the computer. I have been using Arch Linux for a fair amount of time now and I started using it with XFCE for few weeks. I would appreciate the XFCE desktop environment for it’s smoothness and light-weight nature with works really fine when newly shifting on Arch Linux. But then I learnt the suckless ecosystem and eventually shifted to it as my full-time environment.</description>
    </item>
    <item>
      <title>Installing Pacman in Arch Linux — When You Blow it Up</title>
      <link>/technical/installing_pacman_in_arch_linux/</link>
      <pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/installing_pacman_in_arch_linux/</guid>
      <description>Let me suckless and divide the article into two parts:&#xA;My story how I blew up Pacman Package Manager How to reinstall the Pacman Package Manager If you only care about the second part, skip the first one.&#xA;The Scenario — Blow it Up I was trying to install the pacman game from the Internet to get it running on my Arch Linux Terminal (I use Suckless Terminal BTW). When I got it installed and played it, it was super awesome.</description>
    </item>
    <item>
      <title>An Old Computer’s Teachings — Why Vintage Systems Can Make You an Expert</title>
      <link>/thinkings/an_old_computers_teachings/</link>
      <pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/thinkings/an_old_computers_teachings/</guid>
      <description>On June 10 1997, Apple Computers released the Apple 2 computer which was one of the first mass-produced computers in the world. It was a success and had a sale of 5–6 million units till the year of 1993. There was a small documentary on this by Bloomberg Originals (here on YouTube) about the same with Steve Wozniak. Now I am not a 90’s kid or something. I was born in the year 2004 and had no connection with these computers.</description>
    </item>
    <item>
      <title>Boot Process of Computers — A Learner’s Perspective Of Exploring the Depth of Computers</title>
      <link>/technical/boot_process_of_computers/</link>
      <pubDate>Mon, 15 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/boot_process_of_computers/</guid>
      <description>Prior Clarifications: Here, I will be providing a philosophical explanation about the bootloaders and understanding them in a simple and as minimal way as possible. This is not supposed to be a manual for bootloader or provide any advice for experimenting over your live system. It’s my journey to understand computers (one of the most complex creations of mankind) and I will be stating my thoughts. Take it with a pinch of salt.</description>
    </item>
    <item>
      <title>A Minimalist System — Philosophy Behind Terminal-based Applications to Suckless</title>
      <link>/thinkings/a_minimilist_system/</link>
      <pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/thinkings/a_minimilist_system/</guid>
      <description>Since I have been using Linux for most of my life till now and while I started my computer usage on the Windows Operating System (at a very early age), terminal-based programs have been a life-changing things for me. I have been a person obsessed with minimalism and simplicity in everything. While I spend most of my day in the cyber world, I like to have my computer workspace as minimal as possible.</description>
    </item>
    <item>
      <title>The Alchemy of Open-Source Software — Community and Freedom</title>
      <link>/thinkings/alchemcy_of_open_source_software/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/thinkings/alchemcy_of_open_source_software/</guid>
      <description>Disclaimer — The following blog post contains the very personal opinions of the writer and is not intended beyond the scope of stating views about the Open-Source. The author respects the opinions of each individual so take it with a pinch of salt.&#xA;Open-source software has been there for a long time since the software industry started to get into some shape. Open-source is not just a way of developing software but a value that makes individuals in the community contribute to making their skills useful to the world.</description>
    </item>
    <item>
      <title>Networking Fundamentals for Linux Administrators — A Suckless and Concise Explanation</title>
      <link>/technical/networking_fundamentals_for_linux_administrators/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/networking_fundamentals_for_linux_administrators/</guid>
      <description>Statistics are clear on the fact that 96.3% (while writing this article) of the servers use Linux as their Operating System which is no doubt what every other Linux user on this Earth expects. I believe that the Linux Administrator has to take the shot about the configuration of Networking in Linux Based Server. Some of the underlying concepts remain the same for any other distros but it is mainly intended for Linux.</description>
    </item>
    <item>
      <title>Operating Systems and Low-Level Access to the Hardware — Why should you learn it?</title>
      <link>/technical/operating_systems_and_low_level_access_to_the_hardware/</link>
      <pubDate>Tue, 09 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/operating_systems_and_low_level_access_to_the_hardware/</guid>
      <description>Today, I completed the whole read of the book “Linux Kernel in a Nutshell” by Greg Kroah-Hartman and I highly recommend that you go through it if you want to understand how to build your custom configuration of Linux Kernel and all you need to know about all the nuts and bolts. It’s always great to have such handbooks around the desk.&#xA;This blog is about why it’s so awesome to look into the operating system you are using with your hardware and why have a grasp on the Low-Level aspects of a computer.</description>
    </item>
    <item>
      <title>Arch Linux Custom Builds — Freedom of the Operating System</title>
      <link>/technical/arch_linux_custom_builds/</link>
      <pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/arch_linux_custom_builds/</guid>
      <description>While writing this blog, I was reading the book “Linux Kernel in a Nutshell” by Greg Kroab-Hartman and as far as the pages of the book are concerned, it seems to be a two-day read (this is a handbook so reading it once and having around the desk is super useful). By the way, the author has the book left open for download http://www.kroah.com/lkn/ so check that out if you want to follow up.</description>
    </item>
    <item>
      <title>Bypassing the Linux Login to access the files (with Physical Access), even the root!</title>
      <link>/technical/bypass_the_linux_login_to_access_the_files/</link>
      <pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/technical/bypass_the_linux_login_to_access_the_files/</guid>
      <description>Imagine being away from the computer for a couple of minutes and getting to know that the system has been compromised and a backdoor has been installed into the system. “The system was locked?” doesn’t matter, without the bios security implementation (which most probably would not be implemented), all the files can be recovered without any login made to the Login Screen.&#xA;This goes with the story of me trying to get my Wi-Fi troubleshooting in Arch Linux where I was trying to upgrade the Kernel of my System to get the Wi-Fi working properly (as mentioned in the previous blog.</description>
    </item>
    <item>
      <title>The Arch Linux Tales: No Wi-Fi for Today!</title>
      <link>/thinkings/arch_linux_tales/</link>
      <pubDate>Sun, 07 Jan 2024 00:00:00 +0000</pubDate>
      <guid>/thinkings/arch_linux_tales/</guid>
      <description>I have been using Arch Linux for days now for the sake of having full control over the hardware as well as the software (not moved to LibreBoot or CoreBoot but someday in the future). I have been utilising the suckless utilities and ricing my system for the best look I can have and take the privilege of saying “I use Arch BTW”. Since the total control of the Hardware and Software falls in the hands of the user and Arch repository Pacman releases even the latest packages, way before the software is even stable creating a sensation of being the early user of the tool at the same time being ready to crash out the system.</description>
    </item>
    <item>
      <title>8-bit Custom TTL Computer</title>
      <link>/projects/design1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/projects/design1/</guid>
      <description>GitHub: https://github.com/PythonHacker24/8-bit_computer&#xA;A TTL (Transistor-Transistor Logic) computer is a type of computer system that uses transistors as there base components by manipulating them into gates which are then used develop logics. TTL is a family of digital logic ICs that were widely used in the early days of computing and electronics, mainly during the 1960s and 1970s.&#xA;This is a circuit prototye for the development of a custion architecture 8-bit Microprocessor.</description>
    </item>
    <item>
      <title>Binary Tree</title>
      <link>/data_structures/binary_tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/binary_tree/</guid>
      <description>Trees A tree consists of Nodes that points to multiple nodes (In this case, binary tree has been consider where each node can point to at max 2 nodes). The Node that points to other Node is called it’s parent and the Node that is being pointed is called it’s child Node. A parent can have multiple child nodes but a child Node can’t have multiple parent Nodes. A child can also be a parent Node to other child Nodes.</description>
    </item>
    <item>
      <title>Bubble Sort</title>
      <link>/algorithms/bubble_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/bubble_sort/</guid>
      <description>Bubble Sort is a simple, comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted. While easy to understand and implement, Bubble Sort is inefficient for large lists, with a worst-case and average-case time complexity of O(n^2).&#xA;#include &amp;lt;iostream&amp;gt; #include &amp;lt;array&amp;gt; using namespace std; // This function will carry out the operations in the algorithm of Bubble Sort Method int bubbleSort(int array[], int size){ for (int i = size - 1; i &amp;gt; 0; i--){ for (int j = 0; j &amp;lt; i; j++){ if (array[j] &amp;gt; array[j+1]){ int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; } } } } int main(){ int myArray[] = {6, 4, 3, 6, 7, 8, 1, 4, 5, 3}; int size = sizeof(myArray) / sizeof(myArray[0]); // This is the method for calculating the length of an array bubbleSort(myArray, size); for (auto value: myArray){ cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; endl; } } // Operational Complexity for Bubble Sort is O(n^2) </description>
    </item>
    <item>
      <title>Doubly Linked List</title>
      <link>/data_structures/double_ll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/double_ll/</guid>
      <description>A doubly linked list is a type of linked list where each node contains data and references to two other nodes:&#xA;One pointer to the previous node in the list. Another pointer to the next node in the list. This allows you to traverse the list in either direction, which is different from a singly linked list that only allows traversal in one direction. #include &amp;lt;iostream&amp;gt; using namespace std; // Creating the Node Class class Node { public: int value; Node *next; Node *prev; Node(int value) { this-&amp;gt;value = value; next = nullptr; prev = nullptr; } }; // Creating Double Linked List Class class DoublyLinkedList { private: Node *head; Node *tail; int length; public: // Constructor for the Doubly Linked List DoublyLinkedList(int value) { Node *newNode = new Node(value); head = newNode; tail = newNode; length = 1; } // Destructor for the Doubly Linked List ~DoublyLinkedList() { Node* temp = head; while (head) { head = head-&amp;gt;next; delete temp; temp = head; } } // printList will print the Linked List void printList() { Node *temp = head; while (temp !</description>
    </item>
    <item>
      <title>Fault Injector Project</title>
      <link>/projects/design2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/projects/design2/</guid>
      <description>GitHub: https://github.com/PythonHacker24/fault-injector&#xA;What is Fault Injection Attack? Fault Injection Attacks is an hardware attack that glitches a hardware circuit to behave in a way which is not intended and cause uncertain behaviour that would be useful for a hacker.&#xA;This attack is useful in cases of jumping instructions inside a microprocessor or microcontrollers by gltiching the power supply to the chip. This maybe useful for escaping loops, bypassing authentication, etc. More destructive results can be obtained in cases of glitches that has undefined parameters set and may cause the whole electronic circuit to become unusuable due to deleting firmwares or bootloaders.</description>
    </item>
    <item>
      <title>Graphs</title>
      <link>/data_structures/graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/graph/</guid>
      <description>In DSA (Data Structures and Algorithms), a graph is a collection of nodes (also called vertices) connected by edges.&#xA;Nodes represent data. Edges represent the relationships between that data. #include &amp;lt;iostream&amp;gt; #include &amp;lt;unordered_map&amp;gt;&#x9;// Similar to hash table, there are two rows where key-value pair structures are stored. #include &amp;lt;unordered_set&amp;gt;&#x9;// It&amp;#39;s like a array. Here, if same data is pushed into the array, only one instance is created. (Close enough to Hash Table concept) using namespace std; class Graph{ private: unordered_map&amp;lt;string, unordered_set&amp;lt;string&amp;gt; &amp;gt; adjList;&#x9;// unordered_map&amp;lt; data_type, data_type &amp;gt; map_name; // Here, in this case, key is s string and the value is a unordered_set with string values and this whole map is named adjList public: void printGraph(){ for (auto [vertex, edges] : adjList){&#x9;// As per the plan, the structuring is arranged.</description>
    </item>
    <item>
      <title>Hash Tables</title>
      <link>/data_structures/hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/hash/</guid>
      <description>Hash tables are the tables where each piece of data is stored in a given index which is generated when the data is passed through some hash function.&#xA;For example: If {”dataset_1”:1000} would value of 4 (from the hash function), it would be stored in the index of 4. {”dataset_2”:2000} might be 8, so it would be stored in the index of 8.&#xA;It may happen in cases that data can get same index with hash function, in which case a condition on collision occurs.</description>
    </item>
    <item>
      <title>Insertion Sort</title>
      <link>/algorithms/insertion_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/insertion_sort/</guid>
      <description>Insertion Sort is a simple, comparison-based sorting algorithm that builds the final sorted array one element at a time. It works by repeatedly picking the next element from the unsorted portion and inserting it into the correct position within the sorted portion, effectively shifting elements as necessary to make space. This algorithm is efficient for small data sets or nearly sorted arrays but has a quadratic time complexity of O(n^2) for larger, unordered lists.</description>
    </item>
    <item>
      <title>Merge Sort</title>
      <link>/algorithms/merge_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/merge_sort/</guid>
      <description>Merge Sort is a stable, comparison-based sorting algorithm that uses the divide-and-conquer strategy. It works by recursively dividing the array into halves until each sub-array contains a single element, then merges the sub-arrays back together in sorted order. This algorithm is efficient with a consistent time complexity of O(nlogn) and is particularly useful for sorting linked lists and large datasets.&#xA;# include &amp;lt;iostream&amp;gt; using namespace std; void merge(int array[], int leftIndex, int midIndex, int rightIndex){ // Calculating size of the two arrays that are derived from splitting the array int leftArraySize = midIndex - leftIndex + 1; int rightArraySize = rightIndex - midIndex; // Declaring new arrays where these splitted arrays are going to be defined int leftArray[leftArraySize]; int rightArray[rightArraySize]; // Loading new arrays with right and left elements of the array for (int i = 0; i &amp;lt; leftArraySize; i++){ leftArray[i] = array[leftIndex + i]; } for (int j = 0; j &amp;lt; rightArraySize; j++){ rightArray[j] = array[midIndex + 1 + j]; } // initializing variables int index = leftIndex; int i = 0; int j = 0; // Arranging the main array with elements in order of small to large size from the leftArray and rightArray while (i &amp;lt; leftArraySize &amp;amp;&amp;amp; j &amp;lt; rightArraySize){ if (leftArray[i] &amp;lt;= rightArray[j]){ array[index] = leftArray[i]; index++; i++; } else{ array[index] = rightArray[j]; index++; j++; } } // If leftArray elements are left over, add them at the end of the main array while (i &amp;lt; leftArraySize){ array[index] = leftArray[i]; index++; i++; } // If rightArray elements are left over, add them at the end of the main array while (j &amp;lt; rightArraySize){ array[index] = rightArray[j]; index++; j++; } } void mergeSort(int array[], int leftIndex, int rightIndex){ if (leftIndex &amp;gt;= rightIndex) return; int midIndex = leftIndex + (rightIndex - leftIndex) / 2; mergeSort(array, leftIndex, midIndex); mergeSort(array, midIndex + 1, rightIndex); merge(array, leftIndex, midIndex, rightIndex); } int main(){ int myArray[] = {3, 1, 4, 2}; int size = sizeof(myArray) / sizeof(myArray[0]); int leftIndex = 0; int rightIndex = size - 1; mergeSort(myArray, leftIndex, rightIndex); for(auto value : myArray){ cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } } </description>
    </item>
    <item>
      <title>Queue</title>
      <link>/data_structures/queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/queue/</guid>
      <description>Queue works as FIFO (First In First Out). The value that is added first will be the one that can be access first. Here, Linked List would be used in reverse order. A linked list will have prepend function operation complexity to be O(1) and deleteFirst also to be O(1).&#xA;#include &amp;lt;iostream&amp;gt; using namespace std; // Node Class will create a Node class Node{ public: int value; Node* next; Node(int value){ this-&amp;gt;value = value; next = nullptr; } }; // Queue Class will develop the Queue class Queue{ private: Node* first; Node* last; int length; public: // Constructor for the Queue Class Queue(int value){ Node* newNode = new Node(value); first = newNode; last = newNode; length = 1; } // printQueue will print the values in the Queue void printQueue(){ Node* temp = first; while(temp){ cout &amp;lt;&amp;lt; temp-&amp;gt;value &amp;lt;&amp;lt; endl; temp = temp-&amp;gt;next; } } // getFirst will print the value of the first element in the Queue void getFirst(){ cout &amp;lt;&amp;lt; &amp;#34;First: &amp;#34; &amp;lt;&amp;lt; first-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLast will print the value of the last element in the Queue void getLast(){ cout &amp;lt;&amp;lt; &amp;#34;Last: &amp;#34; &amp;lt;&amp;lt; last-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLength will print the length of the Queue void getLength(){ cout &amp;lt;&amp;lt; &amp;#34;Length: &amp;#34; &amp;lt;&amp;lt; length &amp;lt;&amp;lt; endl; } // enqueue will add a element to the Queue void enqueue(int value){ Node* newNode = new Node(value); if (length == 0){ first = newNode; last = newNode; } else{ last-&amp;gt;next = newNode; last = newNode; } length++; } // dequeue will remove a element from the Queue int dequeue(){ if (length == 0) return INT_MIN; Node* temp = first; int dequeuedValue = first-&amp;gt;value; if (length == 1){ first = nullptr; last = nullptr; } else{ first = first-&amp;gt;next; } delete temp; length--; return dequeuedValue; } }; // info function will return information about the given Queue void info(Queue* myQueue){ cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;#34;Printing the Queue&amp;#34; &amp;lt;&amp;lt; endl; myQueue-&amp;gt;printQueue(); myQueue-&amp;gt;getFirst(); myQueue-&amp;gt;getLast(); myQueue-&amp;gt;getLength(); cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; } int main(){ Queue* myQueue = new Queue(4); info(myQueue); myQueue-&amp;gt;enqueue(2); myQueue-&amp;gt;enqueue(8); myQueue-&amp;gt;enqueue(4); myQueue-&amp;gt;enqueue(5); info(myQueue); }#include &amp;lt;iostream&amp;gt; using namespace std; // Node Class will create a Node class Node{ public: int value; Node* next; Node(int value){ this-&amp;gt;value = value; next = nullptr; } }; // Queue Class will develop the Queue class Queue{ private: Node* first; Node* last; int length; public: // Constructor for the Queue Class Queue(int value){ Node* newNode = new Node(value); first = newNode; last = newNode; length = 1; } // printQueue will print the values in the Queue void printQueue(){ Node* temp = first; while(temp){ cout &amp;lt;&amp;lt; temp-&amp;gt;value &amp;lt;&amp;lt; endl; temp = temp-&amp;gt;next; } } // getFirst will print the value of the first element in the Queue void getFirst(){ cout &amp;lt;&amp;lt; &amp;#34;First: &amp;#34; &amp;lt;&amp;lt; first-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLast will print the value of the last element in the Queue void getLast(){ cout &amp;lt;&amp;lt; &amp;#34;Last: &amp;#34; &amp;lt;&amp;lt; last-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLength will print the length of the Queue void getLength(){ cout &amp;lt;&amp;lt; &amp;#34;Length: &amp;#34; &amp;lt;&amp;lt; length &amp;lt;&amp;lt; endl; } // enqueue will add a element to the Queue void enqueue(int value){ Node* newNode = new Node(value); if (length == 0){ first = newNode; last = newNode; } else{ last-&amp;gt;next = newNode; last = newNode; } length++; } // dequeue will remove a element from the Queue int dequeue(){ if (length == 0) return INT_MIN; Node* temp = first; int dequeuedValue = first-&amp;gt;value; if (length == 1){ first = nullptr; last = nullptr; } else{ first = first-&amp;gt;next; } delete temp; length--; return dequeuedValue; } }; // info function will return information about the given Queue void info(Queue* myQueue){ cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;#34;Printing the Queue&amp;#34; &amp;lt;&amp;lt; endl; myQueue-&amp;gt;printQueue(); myQueue-&amp;gt;getFirst(); myQueue-&amp;gt;getLast(); myQueue-&amp;gt;getLength(); cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; } int main(){ Queue* myQueue = new Queue(4); info(myQueue); myQueue-&amp;gt;enqueue(2); myQueue-&amp;gt;enqueue(8); myQueue-&amp;gt;enqueue(4); myQueue-&amp;gt;enqueue(5); info(myQueue); }#include &amp;lt;iostream&amp;gt; using namespace std; // Node Class will create a Node class Node{ public: int value; Node* next; Node(int value){ this-&amp;gt;value = value; next = nullptr; } }; // Queue Class will develop the Queue class Queue{ private: Node* first; Node* last; int length; public: // Constructor for the Queue Class Queue(int value){ Node* newNode = new Node(value); first = newNode; last = newNode; length = 1; } // printQueue will print the values in the Queue void printQueue(){ Node* temp = first; while(temp){ cout &amp;lt;&amp;lt; temp-&amp;gt;value &amp;lt;&amp;lt; endl; temp = temp-&amp;gt;next; } } // getFirst will print the value of the first element in the Queue void getFirst(){ cout &amp;lt;&amp;lt; &amp;#34;First: &amp;#34; &amp;lt;&amp;lt; first-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLast will print the value of the last element in the Queue void getLast(){ cout &amp;lt;&amp;lt; &amp;#34;Last: &amp;#34; &amp;lt;&amp;lt; last-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLength will print the length of the Queue void getLength(){ cout &amp;lt;&amp;lt; &amp;#34;Length: &amp;#34; &amp;lt;&amp;lt; length &amp;lt;&amp;lt; endl; } // enqueue will add a element to the Queue void enqueue(int value){ Node* newNode = new Node(value); if (length == 0){ first = newNode; last = newNode; } else{ last-&amp;gt;next = newNode; last = newNode; } length++; } // dequeue will remove a element from the Queue int dequeue(){ if (length == 0) return INT_MIN; Node* temp = first; int dequeuedValue = first-&amp;gt;value; if (length == 1){ first = nullptr; last = nullptr; } else{ first = first-&amp;gt;next; } delete temp; length--; return dequeuedValue; } }; // info function will return information about the given Queue void info(Queue* myQueue){ cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;#34;Printing the Queue&amp;#34; &amp;lt;&amp;lt; endl; myQueue-&amp;gt;printQueue(); myQueue-&amp;gt;getFirst(); myQueue-&amp;gt;getLast(); myQueue-&amp;gt;getLength(); cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; } int main(){ Queue* myQueue = new Queue(4); info(myQueue); myQueue-&amp;gt;enqueue(2); myQueue-&amp;gt;enqueue(8); myQueue-&amp;gt;enqueue(4); myQueue-&amp;gt;enqueue(5); info(myQueue); }#include &amp;lt;iostream&amp;gt; using namespace std; // Node Class will create a Node class Node{ public: int value; Node* next; Node(int value){ this-&amp;gt;value = value; next = nullptr; } }; // Queue Class will develop the Queue class Queue{ private: Node* first; Node* last; int length; public: // Constructor for the Queue Class Queue(int value){ Node* newNode = new Node(value); first = newNode; last = newNode; length = 1; } // printQueue will print the values in the Queue void printQueue(){ Node* temp = first; while(temp){ cout &amp;lt;&amp;lt; temp-&amp;gt;value &amp;lt;&amp;lt; endl; temp = temp-&amp;gt;next; } } // getFirst will print the value of the first element in the Queue void getFirst(){ cout &amp;lt;&amp;lt; &amp;#34;First: &amp;#34; &amp;lt;&amp;lt; first-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLast will print the value of the last element in the Queue void getLast(){ cout &amp;lt;&amp;lt; &amp;#34;Last: &amp;#34; &amp;lt;&amp;lt; last-&amp;gt;value &amp;lt;&amp;lt; endl; } // getLength will print the length of the Queue void getLength(){ cout &amp;lt;&amp;lt; &amp;#34;Length: &amp;#34; &amp;lt;&amp;lt; length &amp;lt;&amp;lt; endl; } // enqueue will add a element to the Queue void enqueue(int value){ Node* newNode = new Node(value); if (length == 0){ first = newNode; last = newNode; } else{ last-&amp;gt;next = newNode; last = newNode; } length++; } // dequeue will remove a element from the Queue int dequeue(){ if (length == 0) return INT_MIN; Node* temp = first; int dequeuedValue = first-&amp;gt;value; if (length == 1){ first = nullptr; last = nullptr; } else{ first = first-&amp;gt;next; } delete temp; length--; return dequeuedValue; } }; // info function will return information about the given Queue void info(Queue* myQueue){ cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;#34;Printing the Queue&amp;#34; &amp;lt;&amp;lt; endl; myQueue-&amp;gt;printQueue(); myQueue-&amp;gt;getFirst(); myQueue-&amp;gt;getLast(); myQueue-&amp;gt;getLength(); cout &amp;lt;&amp;lt; &amp;#34;----------------&amp;#34; &amp;lt;&amp;lt; endl; } int main(){ Queue* myQueue = new Queue(4); info(myQueue); myQueue-&amp;gt;enqueue(2); myQueue-&amp;gt;enqueue(8); myQueue-&amp;gt;enqueue(4); myQueue-&amp;gt;enqueue(5); info(myQueue); } </description>
    </item>
    <item>
      <title>Quick Sort</title>
      <link>/algorithms/quick_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/quick_sort/</guid>
      <description>Quick Sort is a highly efficient, comparison-based sorting algorithm that uses the divide-and-conquer strategy to sort elements. It works by selecting a &amp;lsquo;pivot&amp;rsquo; element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted. Quick Sort has an average-case time complexity of O(nlogn) and is generally faster in practice compared to other O(nlogn) algorithms like Merge Sort, though its worst-case complexity is O(n^2).</description>
    </item>
    <item>
      <title>Selection Sort</title>
      <link>/algorithms/selection_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/selection_sort/</guid>
      <description>Selection Sort is a simple, comparison-based sorting algorithm that sorts an array by repeatedly finding the minimum element from the unsorted portion and swapping it with the first unsorted element. This process continues moving the boundary of the sorted and unsorted subarrays. While easy to understand and implement, Selection Sort is inefficient for large datasets, with a time complexity of O(n^2).&#xA;# include &amp;lt;iostream&amp;gt; # include &amp;lt;array&amp;gt; using namespace std; // This function will carry out the operations in the algorithm of Selection Sort Method int selectionSort(int array[], int size){ for (int i = 0; i &amp;lt; size; i++){ int minIndex = i; for (int j = i + 1; j &amp;lt; size; j++){ if (array[j] &amp;lt; array[minIndex]){ minIndex = j; } } if (i !</description>
    </item>
    <item>
      <title>Singly Linked List</title>
      <link>/data_structures/linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/linkedlist/</guid>
      <description>Linked Lists and Vectors are different concepts. A Vector has index assigned to it’s elements whereas there are no index in Linked Lists. A Vector has it’s elements stored in memory address consecutively whereas Linked List have it’s elements stored in memory address that are not in any order (arbitrarily assigned). Each element points to the next elements memory address and the last elements points to null value (that means no where).</description>
    </item>
    <item>
      <title>SpikeX - Open Source OSINT Framework</title>
      <link>/projects/design4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/projects/design4/</guid>
      <description>GitHub: https://github.com/PythonHacker24/spikex&#xA;SpikeX is an open-source OSINT framework that is designed for manual web scanning, web scraping, and gathering comprehensive information from the internet. It provides a web interface with a GUI mode for testing and is a passive reconnaissance tool for cybersecurity and penetration testers.&#xA;The tool is powered by the Shodan search engine and can gather a vast amount of data that will expand the attack surface of the penetration testers and provide fast threat intel.</description>
    </item>
    <item>
      <title>Stack</title>
      <link>/data_structures/stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/data_structures/stacks/</guid>
      <description>The stack will be a vertical Linked List that will have it’s tail at the bottom (the actual tail pointer will not be present) and head at the Top (top pointer will be present instead of head pointer). Prepend like function called push will add a node at the top of the stack and pop function will return the value of the popped node and will delete the node when it will be called.</description>
    </item>
    <item>
      <title>The Minimalist&#39;s Book</title>
      <link>/projects/design3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/projects/design3/</guid>
      <description>GitHub: https://github.com/PythonHacker24/theminimalistbook&#xA;The Minimalist&amp;rsquo;s Book is a free and open-source platfrom for my articles about computers, electronics, philosophy and my thinkings. This place is mostly about passion for computers and electronics, focusing on security and the way I think about them. It&amp;rsquo;s a geek&amp;rsquo;s book, for people with curiosity about things reaching at a level where it becomes a lifestyle.&#xA;You can find a lot of things here, especially if you are a Linux Power User and love low level computing.</description>
    </item>
    <item>
      <title>Tree Traversal - Breath First Search</title>
      <link>/algorithms/tree_traversal_breath_first_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/tree_traversal_breath_first_search/</guid>
      <description>Breadth-First Search is a tree traversal algorithm that explores nodes level by level. Starting from the root, it visits all nodes at the current level before moving on to the nodes at the next level. BFS uses a queue to keep track of the nodes to be explored, ensuring that nodes are processed in the order they are discovered. This method is effective for finding the shortest path in unweighted graphs and has a time complexity of O(V+E), where V is the number of vertices and E is the number of edges.</description>
    </item>
    <item>
      <title>Tree Traversal - Depth First Search - In Order Search</title>
      <link>/algorithms/tree_traversal_depth_first_search_in_order_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/tree_traversal_depth_first_search_in_order_search/</guid>
      <description>In-Order Traversal is a type of depth-first search used primarily with binary trees. It visits nodes in a left-root-right sequence: it first recursively visits the left subtree, then processes the current node, and finally recursively visits the right subtree. This traversal method is particularly useful for binary search trees (BSTs) because it visits nodes in ascending order, producing a sorted sequence of values from the tree. The time complexity is O(n), where n is the number of nodes in the tree.</description>
    </item>
    <item>
      <title>Tree Traversal - Depth First Search - Post Order</title>
      <link>/algorithms/tree_traversal_depth_first_search_post_order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/tree_traversal_depth_first_search_post_order/</guid>
      <description>Post-Order Traversal is a type of depth-first search that visits nodes in a left-right-root sequence: it first recursively visits the left subtree, then the right subtree, and finally processes the current node. This traversal is useful for operations where a node must be processed only after all its children have been processed, such as deleting nodes in a tree or evaluating expressions in a syntax tree. The time complexity is O(n), where n is the number of nodes in the tree.</description>
    </item>
    <item>
      <title>Tree Traversal - Depth First Search - Pre Order</title>
      <link>/algorithms/tree_traversal_depth_first_search_pre_order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/algorithms/tree_traversal_depth_first_search_pre_order/</guid>
      <description>Pre-Order Traversal is a type of depth-first search that visits nodes in a root-left-right sequence: it processes the current node first, then recursively visits the left subtree, followed by the right subtree. This traversal is useful for creating a copy of the tree, prefix expression evaluations, and hierarchical structures where the root node is processed before its subtrees. The time complexity is O(n), where n is the number of nodes in the tree.</description>
    </item>
  </channel>
</rss>
